객체 지향 프로그래밍2

배열 -> 모든 자료형으로 만들수 있음. (기본, 참조...)

자료형[] 배열명 = new 자료형[공간갯수];
 ->동일 자료형을 순차적으로 나열한 가료 구조

향상된 for 구문 -> 배열 와 같은 객체들.

java.io.FileInputStream
===========
1. 상속이란?
 - 

2. 클래스 상속
 - 구조 : 자식 class extends(예약어) 부모 class {}
 - 

3. super 예약어
 - 컴파일러가 자동으로 추가해 주는 것
  1) 기본생성자 입력.
  2) 생성자 중괄호 내 super(); 입력. (참고) this; -> 자신 클래스의 객체의 주소값.
 - super; -> 지역변수 : 상위 클래스의 객체 주소값.
 - super(); -> 생성자 : 상위 클래스의 생성자.
   C() extends B() & B() extends A()
 - 생성자 메서드 호출 순서 : C() -> super() -> B() -> super() -> A() [stack]
 - 객체 생성 순서 : A() -> B() -> C() [heap]
 - A(), B() class 내에 선언된 멤버 변수들을 C()에서 사용할 수 있다.

4. 상위클래스로 묵시적 클래스형 변환
 - 하위클래스 -> 상위클래스 형변환(묵시적 형변환 : 자동으로 형변환)
  -> 접근할 수 있는 자원의 크기만 변경.(ex 사용할 수 있는 멤버변수의 갯수가 바뀐다.)
 - 상위 클래스 -> 하위클래스(명시적 형변환 : 수동으로 형변환)
  -> 상위 클래스 객체의 출처가 명확하지 않기 때문이다.
  -> 실제 출처가 명확하지 않은(D()) 클래스의 객체를 형변환 시 오류가 발생한다.

5. 다형성
 - instanceof 로 객체의 출처 확인 후 대입.
 ex) Human, Bird, Tiger, Fish < Animal

6. 메서드 오버라이딩(재정의)
 - 각 상위 클래스의 기능을 하위 클래스의 객체에 맞게 변경하고 싶은경우 메서드 오버라이드(재정의)한다.
 - 하위 클래스에서 메서드 오버라이드를 할 경우, 호출 시 하위 클래스의 메서드가 호출된다.

참고) 애노테이션(Annotation : 주석, 주해)
 - 정보전달을 목표로함(별도 기능 X)
@Override : 상위 클래스에 정의되어 있는 메서드인지? 
 -> 실수를 방지하기 위해 사용.
 -> 컴파일러에 정보 전달(정보 : 이 클래스의 메서드는 재정의 메서드)

가상메서드 테이블

7.묵시적 형변환과 메서드 재정의